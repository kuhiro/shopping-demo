
var doc      = require('dynamodb-doc');
var dynamodb = new doc.DynamoDB();

var Utils    = require('utilities');

exports.get = function(params, next) {
  Utils.Log('Data.get'); Utils.Log(params);
  dynamodb.getItem(params, next);
}

exports.put = function(params, next) {
  Utils.Log('Data.put'); Utils.Log(params);
  dynamodb.putItem(params, next);
}

function initialize_update_expression(uparams, del, first) {
  if (!uparams.UpdateExpression.length) {
    var op = del ? "remove " : "set ";
    uparams.UpdateExpression = op;
  } else {
    if (!first) {
      uparams.UpdateExpression += ", ";
    }
  }
}

function add_comma_update_expression(uparams, i, xs) {
  if (i !== (xs.length - 1)) uparams.UpdateExpression += ", ";
}

function initialize_expression_attribute_names(uparams) {
  if (!uparams.ExpressionAttributeNames) uparams.ExpressionAttributeNames = {};
}

// NOTE: only one level of nesting supported (e.g. arr.1, not arr.1.1)
function rewrite_nested_field_update(uparams, i, dots, val, vname, incr) {
  var kname = "#k" + i;
  var arr   = dots.split(".");
  var res   = "";
  for (var j = 0; j < arr.length; j++) {
    var a = arr[j];
    if (isNaN(a)) res += a;
    else {
      initialize_expression_attribute_names(uparams);
      uparams.ExpressionAttributeNames[kname] = a;
      res += kname;
    }
    if (j !== (arr.length - 1)) res += ".";
  }
  if (incr) {
    uparams.UpdateExpression += res + " = " + res + " + " + vname;
  } else {
    uparams.UpdateExpression += res + " = " + vname;
  }
  uparams.ExpressionAttributeValues[vname] = val;
}

function rewrite_normal_update(uparams, i, dots, val, vname, incr) {
  var kname = "#k" +i;
  if (incr) {
    uparams.UpdateExpression += kname + " = " + kname + " + " + vname;
  } else {
    uparams.UpdateExpression += kname + " = " + vname;
  }
  initialize_expression_attribute_names(uparams);
  uparams.ExpressionAttributeNames[kname]  = dots;
  uparams.ExpressionAttributeValues[vname] = val;
}

function prepend_list_update(uparams, i, dots, val, vname) {
  var kname = "#p" + i;
  initialize_expression_attribute_names(uparams);
  uparams.ExpressionAttributeNames[kname] = dots;
  uparams.UpdateExpression += kname +
                              " = list_append(" + kname + ", " + vname + ")";
  uparams.ExpressionAttributeValues[vname] = [val];
}

function update_dynamo_params_sets(uparams, sets, cnt) {
  if (sets.length === 0) return cnt;
  initialize_update_expression(uparams, false, true);
  for (var i = 0; i < sets.length; i++) {
    cnt++;
    var set   = sets[i];
    var dots  = set[0];
    var val   = set[1];
    var vname = ":sv" + cnt;
    if (dots.indexOf(".") === -1) {
      rewrite_normal_update(uparams, cnt, dots, val, vname, false)
    } else {
      rewrite_nested_field_update(uparams, cnt, dots, val, vname, false);
    }
    add_comma_update_expression(uparams, i, sets);
  }
  return cnt;
}

function update_dynamo_params_deletes(uparams, dels, cnt) {
  if (dels.length === 0) return cnt;
  initialize_update_expression(uparams, true, false);
  for (var i = 0; i < dels.length; i++) {
    cnt++;
    var del   = dels[i];
    var dots  = del[0];
    var vname = ":dv" + cnt;
    uparams.UpdateExpression += dots + " = " + vname;
    add_comma_update_expression(uparams, i, dels);
  }
  return cnt;
}

function update_dynamo_params_increments(uparams, incrs, cnt) {
  if (incrs.length === 0) return cnt;
  initialize_update_expression(uparams, false, false);
  for (var i = 0; i < incrs.length; i++) {
    cnt++;
    var incr  = incrs[i];
    var dots  = incr[0];
    var byval = incr[1];
    var vname = ":iv" + cnt;
    if (dots.indexOf(".") === -1) {
      rewrite_normal_update(uparams, cnt, dots, byval, vname, true)
    } else {
      rewrite_nested_field_update(uparams, cnt, dots, byval, vname, true);
    }
    add_comma_update_expression(uparams, i, incrs);
  }
  return cnt;
}

// DynamoDB only supports APPEND and PREPEND via list_append()
function update_dynamo_params_inserts(uparams, inserts, cnt) {
  if (inserts.length === 0) return cnt;
  initialize_update_expression(uparams, false, false);
  for (var i = 0; i < inserts.length; i++) {
    cnt++;
    var insert = inserts[i];
    var dots   = insert[0];
    var pos    = insert[1];
    var val    = insert[2];
    var vname = ":tv" + cnt;
    if (pos === 0) {
      prepend_list_update(uparams, cnt, dots, val, vname);
    } else {
      console.error("DYNAMODB-SHIM: MIDDLE INSERT -> NOT YET SUPPORTED");
    }
    add_comma_update_expression(uparams, i, inserts);
  }
  return cnt;
}

exports.update = function(params, next) {
  Utils.Log('Data.update'); Utils.Log(params);
  var uparams = {
    TableName                 : params.TableName,
    Key                       : params.Key,
    UpdateExpression          : "",
    ExpressionAttributeValues : {},
    ReturnValues              :"UPDATED_NEW"
  };
  var updates = params.Updates;
  var sets    = [];
  var dels    = [];
  var incrs   = [];
  var inserts = [];
  for (var i = 0; i < updates.length; i++) {
    var u = updates[i];
    if        (u.operation === "SET") {
      var dots = u.values[0];
      var val  = u.values[1];
      sets.push([dots, val]);
    } else if (u.operation === "DELETE") {
      var dots = u.values[0];
      dels.push([dots]);
    } else if (u.operation === "INCREMENT") {
      var dots  = u.values[0];
      var byval = u.values[1];
      incrs.push([dots, byval]);
    } else if (u.operation === "INSERT") {
      var dots = u.values[0];
      var pos  = u.values[1];
      var val  = u.values[2];
      inserts.push([dots, pos, val]);
    }
  }
  var cnt = 0;
  cnt = update_dynamo_params_sets      (uparams, sets, cnt);
  cnt = update_dynamo_params_deletes   (uparams, dels, cnt);
  cnt = update_dynamo_params_increments(uparams, incrs, cnt);
  cnt = update_dynamo_params_inserts   (uparams, inserts, cnt);

  Utils.Log('UPDATE: UPARAMS'); Utils.Log(uparams);
  dynamodb.updateItem(uparams, next);
}

